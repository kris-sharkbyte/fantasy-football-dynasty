---
description: Standards and guidelines for Angular 20 code patterns, signals, and service design.
globs:
  - 'src/**/*.ts'
  - 'src/**/*.html'
alwaysApply: true
---

# Coding Standards & Best Practices

This document outlines how we prefer to structure and maintain our codebase.

---

## General Coding Principles

- **Prefer simple solutions** — avoid unnecessary abstraction or overengineering.
- **Eliminate duplication** — check for existing patterns, utilities, or logic before adding new code.
- **Be environment-aware** — ensure changes work across `dev`, `test`, `staging`, and `prod`.
- **Stay scoped to the request** — only make changes that are requested or clearly related.
- **Bug fixes first, new tech later** — don’t introduce new patterns/tech when fixing bugs unless absolutely necessary. If you must, remove the old implementation to avoid duplication.
- **Keep the codebase clean and organized** — consistent naming, formatting, and file structure.
- **Enforce file size limits** — avoid files over 200–300 lines; extract into subcomponents/services if needed.
- **No mocks in real environments** — mocking is for tests only, never for dev/staging/prod.
- **Never overwrite environment files** without explicit approval.

---

## Component Guidelines

- **File structure**: components should always have `.html`, `.scss`, and `.ts` files.
- **Styling**: review `global.scss` and `/theme` before adding new styles; prefer shared theming.
- **Inputs/Outputs**: always use Angular’s `input()` / `output()` signals (Angular 17+).
- **Signals in components**:
  - Templates can access private members → no need to mirror signals as public `asReadonly()`.
  - Use `asReadonly()` only when exposing signals across class boundaries (e.g., services).

---

## Angular 20 + Signals Best Practices

- **Private writable, public readonly**: prefix writable signals with `_foo` and keep them private.
- **Expose intent APIs**: update state through methods, not raw `.set()`/`.update()` scattered in components.
- **Use `computed`**: group multiple signals into a single `vm` object for cleaner templates.
- **Use `effect()` for side effects**: Angular auto-disposes these; avoid manual RxJS-style subscriptions where possible.
- **Keep signals immutable**: replace arrays/objects with new instances on update.
- **Avoid `any`**: define lightweight domain interfaces (e.g., `Bid`, `MarketSummary`).
- **Promote state to a service store** only if:
  - Multiple components need it,
  - It must outlive the component, or
  - It coordinates cross-feature logic.

---

## Angular 20 Service Best Practices

### General Principles

- Keep services **lean and intent-based** — expose domain actions, not raw setters.
- Use `asReadonly()` when exposing state from services.
- Stick to **typed interfaces**, not `any`.
- Normalize error handling (throw or return — not both).
- Remove duplicate/dead code paths.

### Initialization

- Don’t run async code in constructors.
- Use an explicit `init()` or an `effect()` reacting to signals like `selectedLeague`.

### State Management

- Use **private signals** inside services.
- Expose **readonly signals** for consumers.
- Create a `vm = computed(...)` when multiple signals are needed in components.

### Firestore Access

- Always use `serverTimestamp()` for dates.
- Use **typed converters** to enforce schema.
- Ensure indexes exist for combined `where` + `orderBy`.
- Use **transactions** (`runTransaction`) for atomic checks and writes.
- Generate IDs with `doc(collection(...)).id`.

### Real-Time Listeners

- Auto-manage with `DestroyRef` and `effect()`.
- Recreate listeners when keys (like `leagueId` or `weekNumber`) change.
- Clean up properly (especially for feature-scoped services).

### Domain Logic

- Centralize evaluation/simulation in **domain modules** (e.g., `FAWeekManager`).
- Guard against edge cases (e.g., divide-by-zero).
- Keep defaults immutable (`readonly defaultSettings`).

### Data Loading & Queries

- Avoid `any[]`; define small interfaces.
- Use cursor-based pagination (`startAfter`) instead of slicing large arrays.
- Cap search results and filter invalid data up front.

### Logging & Observability

- Replace `console.log` with a `LoggerService`.
- Prefix logs with context (`[FA]`, `[Team]`).

### Security & Consistency

- Assume **Firestore security rules** will validate invariants (max bids, ownership, state transitions).
- Always pair writes with **server-side validation** (`serverTimestamp`, transactions).

---

## Things to Avoid

- ❌ Async Firestore calls in constructors.
- ❌ Arrays of unsubscribe functions; use `DestroyRef` instead.
- ❌ Inconsistent error handling (mixing `throw`, `null`, `false`).
- ❌ Using `any` in APIs or signals.
- ❌ Legacy/duplicate methods left behind.
- ❌ Public/private signal mirrors in components.

---
